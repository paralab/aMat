/**
 * @file example04a.cpp, example04a.hpp
 * 
 * @author Hari Sundar   hsundar@gmail.com
 * @author Han Duc Tran  hantran@cs.utah.edu
 * 
 * @brief Solving 3D Poisson equation by FEM, in parallel, using aMat with linear 4-node tetrahedra elements (mesh is generated by Gmsh)
 * @brief mesh file generated by Gmsh: ex4_linear_4p.msh (73745 nodes, partition to run with 4 processes)
 *                                     ex4_linear_8p.msh (73745 nodes, partition to run with 8 processes)
 *                                     (these meshes were created for L = 1)
 * @brief (this example was ex5 in in aMat_for_paper/)
 * @brief Governing equation: grad^2(u) + sin(2*M_PI*x) * sin(2*M_PI*y) * sin(2*M_PI*z) = 0 on domain L x L x L
 * @brief BCs: u = 0 on all boundaries
 * @brief Exact solution: (L^2 / (12.0 * M_PI * M_PI)) * sin(2 * M_PI * x/L) * sin(2 * M_PI * y/L) * sin(2 * M_PI * z/L);
 * @brief For this example, L = 1, thus the Gmsh meshes need to follow this size
 *
 * @version 0.1
 * @date 2018-11-30
 * @update: 2021-07-28
 *
 * @copyright Copyright (c) 2018 School of Computing, University of Utah
 *
 */
#include "example04a.hpp"
AppData example04aAppData;

// number of cracks allowed in 1 element
#define MAX_CRACK_LEVEL 0

// max number of block dimensions in one cracked element
#define MAX_BLOCKS_PER_ELEMENT (1u << MAX_CRACK_LEVEL)

//=============================================================================================
void usage() {
    std::cout << "\n";
    std::cout << "Usage:\n";
    std::cout << "./example04a <method> <BC method> <n Streams> <meshfile> <outFile>\n";
    std::cout << "\n";
    exit(0);
}

//=============================================================================================


void compute_nodal_body_force(double* xe, unsigned int nnode, double L, double* be) {
   double x, y, z;
   for (unsigned int nid = 0; nid < nnode; nid++){
      x       = xe[nid * 3];
      y       = xe[nid * 3 + 1];
      z       = xe[nid * 3 + 2];
      be[nid] = sin(2 * M_PI * (x/L)) * sin(2 * M_PI * (y/L)) * sin(2 * M_PI * (z/L));
   }
}

//=============================================================================================
// function to give the prescribed value for boundary nodes, in this example, all prescribed values are 0
void computeDispl(const double * xyz, double * uvw) {
   *uvw = 0.0;
}

//=============================================================================================
// function to compute element matrix, used in method 2
void computeElemMat(unsigned int eid, double* ke, double* xe) {

   GmshMesh * p_mesh = example04aAppData.p_mesh;
   unsigned int ** localMap = p_mesh->get_localMap();
   unsigned int * nNodesPerElem = p_mesh->get_nNodesPerElem();
   unsigned int nnodes = nNodesPerElem[eid];

   for (unsigned int n = 0; n < nnodes; n++) {
      const unsigned int localNid = localMap[eid][n];
      xe[n * 3] = p_mesh->get_x(localNid);
      xe[(n * 3) + 1] = p_mesh->get_y(localNid);
      xe[(n * 3) + 2] = p_mesh->get_z(localNid);
   }
   if (nnodes == 4) {
      ke_tet4(ke, xe, example04aAppData.intData->Pts_n_Wts, example04aAppData.NGT);
   }
   else {
      printf("error in computeElemMat function, nnodes = %d, not supported\n", nnodes);
      exit(1);
   }

   return;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[]){

   const unsigned int NDOF_PER_NODE = 1;      // number of dofs per node
   const unsigned int NDIM = 3;               // number of dimension
   const unsigned int NNODE_PER_ELEM = 4;

   const unsigned int NDOF_PER_ELEM = NDOF_PER_NODE * NNODE_PER_ELEM;

   // domain sizes: L x L x L - length of the (global) domain in x, y, z direction
   // L is only used for computing nodal body force: b(x,y,z) = sin(2 * M_PI * (x/L)) * sin(2 * M_PI * (y/L)) * sin(2 * M_PI * (z/L)); and for computing the exact solution
   const double L = 1.0;

   // Gauss points and weights for stiffness matrix integration (transformed to standard cube), NGT is number of Gauss points in each direction
   const unsigned int NGT = 4;
   integration<double> intData(NGT);
   
   unsigned int matType = atoi(argv[1]); // solving method
   unsigned int bcMethod = atoi(argv[2]); // bc method
   const unsigned int nStreams = atoi(argv[3]); // number of streams used for method 3, 4, 5
   const std::string gmshFile = argv[4]; // mesh file name
   const char* outputFile = argv[5]; // output file

   if (argc < 6) usage();

   // element matrix and vector (4-node tetrahedra)
   std::vector<Matrix<double, NDOF_PER_ELEM, NDOF_PER_ELEM>> kee; // element matrix
   kee.resize(MAX_BLOCKS_PER_ELEMENT * MAX_BLOCKS_PER_ELEMENT);
   std::vector<Matrix<double, NDOF_PER_ELEM, 1>> fee;
   fee.resize(MAX_BLOCKS_PER_ELEMENT);
   double * xe = new double [NDIM * NNODE_PER_ELEM];
   double * be = new double [NNODE_PER_ELEM];

   // timing variables
   profiler_t elem_compute_time;
   profiler_t setup_time;
   profiler_t matvec_time;
   
   elem_compute_time.clear();
   setup_time.clear();
   matvec_time.clear();

   const double zero_number = 1E-12;

   PetscInitialize(&argc, &argv, NULL, NULL);
   int rank, size;
   MPI_Comm comm = PETSC_COMM_WORLD;
   MPI_Status Stat;
   MPI_Comm_rank(comm, &rank);
   MPI_Comm_size(comm, &size);

   if (!rank) {
      std::cout << "============ parameters read  =======================\n";
      std::cout << "\t\tMethod = " << matType << "\n";
      std::cout << "\t\tBC method (0 = 'identity-matrix'; 1 = penalty): " << bcMethod << "\n";
      if ((matType == 3) || (matType == 4) || (matType == 5)){
         std::cout << "\t\tNumber of streams: " << nStreams << "\n";
      }
   }

   #ifdef HYBRID_PARALLEL
   if (!rank) {
      std::cout << "\t\tHybrid parallel OpenMP + MPI\n";
      std::cout << "\t\tMax number of threads: " << omp_get_max_threads() << "\n";
      std::cout << "\t\tNumber of MPI processes: " << size << "\n";
   }
   #else
   if (!rank) {
      std::cout << "\t\tOnly MPI parallel\n";
      std::cout << "\t\tNumber of MPI processes: " << size << "\n";
   }
   #endif

   // get mesh provided by Gmsh ========================================================
   GmshMesh mesh(comm, NDOF_PER_NODE);
   mesh.setGmshMesh(gmshFile); // read text file and build local mesh
   
   unsigned int nelem_owned = mesh.get_nOwnedElems(); // number of owned elements
   printf("rank %d, number of owned elements= %d\n", rank, nelem_owned);
   unsigned int * * localDofMap = mesh.get_localDofMap();
   unsigned int * nDofsPerElem = mesh.get_nDofsPerElem();
   unsigned int nLocalDofs = mesh.get_nLocalDofs();
   unsigned long * local2GlobalDofMap = mesh.get_local2GlobalDofMap();
   unsigned long startGlobalDof = mesh.get_startGlobalDof();
   unsigned long endGlobalDof = mesh.get_endGlobalDof();
   unsigned long nDofsTotal = mesh.get_nDofsTotal();
   printf("rank %d, number of dofs total= %d\n", rank, nDofsTotal);

   unsigned int * nNodesPerElem = mesh.get_nNodesPerElem();
   unsigned int ** localMap = mesh.get_localMap(); // pointer to local map, used for getting nodal coordinates {x,y,z}
   
   unsigned int nConstraints = mesh.get_n_constraints();
   printf("rank %d, number of constraints= %d\n", rank, nConstraints);
   
   unsigned long * constrainedDofs = mesh.get_constrained_dofs();
   double * prescribedValues = mesh.get_prescribed_values(&computeDispl);

   // set application data to AppData
   example04aAppData.NGT = NGT;
   example04aAppData.intData = &intData;
   example04aAppData.p_mesh = &mesh;

   // provide Gmsh mesh to aMat ========================================================
   par::Maps<double, unsigned long, unsigned int> meshMaps(comm);

   meshMaps.set_map(nelem_owned,
                  localDofMap,
                  nDofsPerElem,
                  nLocalDofs,
                  local2GlobalDofMap,
                  startGlobalDof,
                  endGlobalDof,
                  nDofsTotal);

   meshMaps.set_bdr_map(constrainedDofs, prescribedValues, nConstraints);

   // declare aMat object
   typedef par::aMat<par::aMatBased<double, unsigned long, unsigned int>, double, unsigned long, unsigned int> 
      aMatBased; // aMat type taking aMatBased as derived class
   typedef par::aMat<par::aMatFree<double, unsigned long, unsigned int>, double, unsigned long, unsigned int> 
      aMatFree; // aMat type taking aMatBased as derived class

   aMatBased* stMatBased; // pointer of aMat taking aMatBased as derived
   aMatFree* stMatFree;   // pointer of aMat taking aMatFree as derived

   if (matType == 0){
      // assign stMatBased to the derived class aMatBased
      stMatBased = new par::aMatBased<double, unsigned long, unsigned int>(meshMaps, (par::BC_METH)bcMethod);
   } else {
      // assign stMatFree to the derived class aMatFree
      stMatFree = new par::aMatFree<double, unsigned long, unsigned int>(meshMaps, (par::BC_METH)bcMethod);
      stMatFree->set_matfree_type((par::MATFREE_TYPE)matType);
      #ifdef USE_GPU
      if ((matType == 3) || (matType == 4) || (matType == 5)){
         stMatFree->set_num_streams(nStreams);
      }
      #endif
   }

   // set function to compute element matrix if using matrix-free
   if (matType == 2){
      stMatFree->set_element_matrix_function(&computeElemMat);
   }

   // create rhs, solution and exact solution vectors
   Vec rhs, out, sol_exact, error;
   par::create_vec(meshMaps, rhs);
   par::create_vec(meshMaps, out);
   par::create_vec(meshMaps, sol_exact);
   par::create_vec(meshMaps, error);

   // compute element stiffness matrix and assemble global stiffness matrix and load vector
   for (unsigned int eid = 0; eid < nelem_owned; eid++) {
      // number of nodes of element eid
      const unsigned int nnodes = nNodesPerElem[eid];
      for (unsigned int nid = 0; nid < nnodes; nid++) {
         const unsigned int localNid = localMap[eid][nid];
         xe[nid * 3]       = mesh.get_x(localNid);
         xe[(nid * 3) + 1] = mesh.get_y(localNid);
         xe[(nid * 3) + 2] = mesh.get_z(localNid);
      }

      setup_time.start();
      elem_compute_time.start();
      ke_tet4(kee[0], xe, intData.Pts_n_Wts, NGT);
      elem_compute_time.stop();

      // assemble element stiffness matrix to global K
      if (matType == 0)
         stMatBased->set_element_matrix(eid, kee[0], 0, 0, 1);
      else
         stMatFree->set_element_matrix(eid, kee[0], 0, 0, 1);
      setup_time.stop();

      // compute nodal values of body force
      compute_nodal_body_force(xe, nnodes, L, be);

      // compute element load vector due to body force
      fe_tet4(fee[0], xe, be, intData.Pts_n_Wts, NGT);

      // assemble element load vector to global F
      par::set_element_vec(meshMaps, rhs, eid, fee[0], 0u, ADD_VALUES);
   }
   delete[] xe;
   delete[] be;

   setup_time.start();
   if (matType == 0){
      stMatBased->finalize(); // Pestc begins and completes assembling the global stiffness matrix
   } else {
      stMatFree->finalize(); // compute trace of matrix when using penalty method
   }
   setup_time.stop();

   // These are needed because we used ADD_VALUES for rhs when assembling
   // now we are going to use INSERT_VALUE for Fc in apply_bc_rhs
   VecAssemblyBegin(rhs);
   VecAssemblyEnd(rhs);

   // apply bc for rhs: this must be done before applying bc for the matrix
   // because we use the original matrix to compute KfcUc in matrix-based method
   if (matType == 0)
      stMatBased->apply_bc(rhs); // this includes applying bc for matrix in matrix-based approach
   else
      stMatFree->apply_bc(rhs);

   VecAssemblyBegin(rhs);
   VecAssemblyEnd(rhs);

   // apply bc to the matrix
   if (matType == 0) {
      setup_time.start();
      stMatBased->finalize();
      setup_time.stop();
   }

   // ====================== profiling matvec ====================================
   // generate random vector of length = number of owned dofs
   /* const unsigned int numDofsTotal = meshMaps.get_NumDofsTotal();
   const unsigned int numDofs = meshMaps.get_NumDofs();

   double* X = (double*) malloc(sizeof(double) * (numDofsTotal));
   for (unsigned int i = 0; i < (numDofsTotal); i++){
      //X[i] = (double)std::rand()/(double)(RAND_MAX/5.0);
      X[i] = 1.0;
   }
   // result vector Y = [K] * X
   double* Y = (double*) malloc(sizeof(double) * (numDofsTotal));

   // total number of matvec's we want to profile
   const unsigned int num_matvecs = 10;
   if (rank == 0) printf("Number of matvecs= %d\n", num_matvecs);

   if( matType==0) {
      Vec petsc_X, petsc_Y;
      par::create_vec(meshMaps, petsc_X, 1.0);
      par::create_vec(meshMaps, petsc_Y);

      for (unsigned int i = 0; i < num_matvecs; i++){
         petsc_matvec_time.start();
         stMatBased->matmult(petsc_Y, petsc_X);
         //VecAssemblyBegin(petsc_X);
         //VecAssemblyEnd(petsc_X);
         petsc_matvec_time.stop();
         VecSwap(petsc_Y, petsc_X);
      }
      VecDestroy(&petsc_X);
      VecDestroy(&petsc_Y);

   } else {
      for (unsigned int i = 0; i < num_matvecs; i++){
         
         aMat_matvec_time.start();     
               stMatFree->matvec(Y, X, true);
         aMat_matvec_time.stop();
         double * temp = X;
         X = Y;
         Y = temp;
      }
   }

   free (Y);
   free (X); */

   // ======================= solve =================================================
   matvec_time.start();
   if (matType == 0)
      par::solve(*stMatBased, (const Vec)rhs, out);
   else
      par::solve(*stMatFree, (const Vec)rhs, out);
   matvec_time.stop();
   

   // ============================ comparing with exact solution =================
   PetscScalar norm, alpha = -1.0;

   VecNorm(out, NORM_2, &norm);
   if (!rank) {
      printf("L2 norm of computed solution = %f\n", norm);
   }

   // compute exact solution for comparison
   Matrix<double, NNODE_PER_ELEM, 1> e_exact;

   for (unsigned int eid = 0; eid < nelem_owned; eid++) {
      for (unsigned int nid = 0; nid < NDOF_PER_ELEM; nid++) {
         const unsigned int localNid = localMap[eid][nid];
         // nodal coordinates
         const double x = mesh.get_x(localNid);
         const double y = mesh.get_y(localNid);
         const double z = mesh.get_z(localNid);

         // exact solution at node n (and apply BCs)
         if ((std::abs(x) < zero_number) || (std::abs(x - L) < zero_number) ||
               (std::abs(y) < zero_number) || (std::abs(y - L) < zero_number) ||
               (std::abs(z) < zero_number) || (std::abs(z - L) < zero_number)) {
               e_exact(nid) = 0.0; // boundary
         } else {
               e_exact(nid) = ((L*L) / (12.0 * M_PI * M_PI)) * sin(2 * M_PI * (x/L)) * sin(2 * M_PI * (y/L)) *
                           sin(2 * M_PI * (z/L));
         }
      }
      // set exact solution to Pestc vector
      par::set_element_vec(meshMaps, sol_exact, eid, e_exact, 0u, INSERT_VALUES);
   }

   // Pestc begins and completes assembling the exact solution
   VecAssemblyBegin(sol_exact);
   VecAssemblyEnd(sol_exact);

   //sprintf(fname, "exactVec_%d.dat", size);
   //par::dump_vec(meshMaps, sol_exact, fname);

   VecNorm(sol_exact, NORM_2, &norm);
   if (!rank) {
      printf("L2 norm of exact solution = %f\n", norm);
   }
   
   // compute the error vector
   VecCopy(sol_exact, error);

   // subtract error = sol_exact - out
   VecAXPY(error, alpha, out);

   // compute norm of error
   VecNorm(error, NORM_INFINITY, &norm);

   if (rank == 0) {
      printf("L_inf norm of error = %20.10f\n", norm);
   }
   // ============================ finish comparing with exact solution ============

   // computing time acrossing ranks and display
   long double elem_compute_maxTime;
   long double setup_maxTime;
   long double matvec_maxTime;
   MPI_Reduce(&elem_compute_time.seconds, &elem_compute_maxTime, 1, MPI_LONG_DOUBLE, MPI_MAX, 0, comm);
   MPI_Reduce(&setup_time.seconds, &setup_maxTime, 1, MPI_LONG_DOUBLE, MPI_MAX, 0, comm);
   MPI_Reduce(&matvec_time.seconds, &matvec_maxTime, 1, MPI_LONG_DOUBLE, MPI_MAX, 0, comm);

   
   // output timing to screen and output file in csv format, open in append mode ================================
   std::ofstream outFile;
   if (rank == 0)
      outFile.open(outputFile, std::fstream::app);

   if (matType == 0) {
      if (rank == 0) {
         std::cout << "(1) PETSc elem compute time = " << elem_compute_maxTime << "\n";
         std::cout << "(2) PETSc setup time = "        << setup_maxTime << "\n";
         std::cout << "(3) PETSc matvec time = "       << matvec_maxTime << "\n";
         outFile << "PETSc, " << elem_compute_maxTime << "," << setup_maxTime << "," << matvec_maxTime << "\n";
      }
   } else if (matType == 1) {
      if (rank == 0) {
         std::cout << "(1) aMat-hybrid elem compute time = " << elem_compute_maxTime << "\n";
         std::cout << "(2) aMat-hybrid setup time = "        << setup_maxTime << "\n";
         std::cout << "(3) aMat-hybrid matvec time = "       << matvec_maxTime << "\n";
         outFile << "aMat-hybrid, " << elem_compute_maxTime << ", " << setup_maxTime << ", " << matvec_maxTime << "\n";
      }
   } else if (matType == 2) {
      if (rank == 0) {
         std::cout << "(3) aMat-free matvec time = " << matvec_maxTime << "\n";
         outFile << "aMat-free, " << matvec_maxTime << "\n";
      }
   } else if ((matType == 3) || (matType == 4) || (matType == 5)) {
      if (rank == 0) {
         std::cout << "(1) aMatGpu elem compute time = " << elem_compute_maxTime << "\n";
         std::cout << "(2) aMatGpu setup time = " << setup_maxTime << "\n";
         std::cout << "(3) aMatGpu matvec time = " << matvec_maxTime << "\n";
         outFile << "aMatGpu, " << elem_compute_maxTime << ", " << setup_maxTime << ", " << matvec_maxTime << "\n";
      }
   }
   if (rank == 0) outFile.close();

   #ifdef AMAT_PROFILER
   stMat->profile_dump(std::cout);
   #endif

   if (matType == 0) {
      delete stMatBased;
   } else {
      delete stMatFree;
   }

   // clean up Pestc vectors
   VecDestroy(&out);
   VecDestroy(&sol_exact);
   VecDestroy(&rhs);
   PetscFinalize();

   return 0;
}